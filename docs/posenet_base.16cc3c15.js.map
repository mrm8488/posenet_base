{"version":3,"sources":["index.js"],"names":["videoWidth","videoHeight","colorLeft","colorRight","draw","point","ctx","y","x","r","color","beginPath","arc","Math","PI","fillStyle","fill","keyPoints","keypoints","minConfidence","scale","leftWrist","find","part","rightWrist","score","position","poseNetState","algorithm","input","architecture","outputStride","inputResolution","multiplier","quantBytes","singlePoseDetection","minPoseConfidence","minPartConfidence","output","showVideo","showPoints","isMobile","test","navigator","userAgent","setupCamera","mediaDevices","getUserMedia","Error","mobile","video","document","getElementById","width","height","audio","facingMode","undefined","stream","srcObject","Promise","resolve","onloadedmetadata","loadVideo","play","detectPoseInRealTime","model","canvas","getContext","flipPoseHorizontal","poseDetectionFrame","poses","estimatePoses","flipHorizontal","decodingMethod","pose","concat","clearRect","save","translate","restore","forEach","requestAnimationFrame","start","posenet","load","poseNetModel","catch","console","error"],"mappings":";AAAA,aA0JA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,MAAA,GAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,QAAA,QAAA,GAAA,KAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,WAAA,IAAA,EAAA,KAAA,EAAA,UAAA,OAAA,IAAA,QAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,OAAA,MAxJA,IAAMA,EAAa,IACbC,EAAc,IACdC,EAAY,UACZC,EAAa,UAEbC,EAAO,CACXC,MAAO,SAACC,EAAKC,EAAGC,EAAGC,EAAGC,GACpBJ,EAAIK,YACJL,EAAIM,IAAIJ,EAAGD,EAAGE,EAAG,EAAG,EAAII,KAAKC,IAC7BR,EAAIS,UAAYL,EAChBJ,EAAIU,QAENC,UAAW,SAACC,EAAWC,EAAeb,GAAKc,IAAAA,EAAQ,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAC7CC,EAAYH,EAAUI,KAAK,SAAAjB,GAASA,MAAe,cAAfA,EAAMkB,OAC1CC,EAAaN,EAAUI,KAAK,SAAAjB,GAASA,MAAe,eAAfA,EAAMkB,OAE3CF,GAAAA,EAAUI,MAAQN,EAAe,CAClBE,IAAAA,EAAAA,EAAUK,SAAnBnB,EAAAA,EAAAA,EAAGC,EAAAA,EAAAA,EACXJ,EAAKC,MAAMC,EAAKC,EAAIa,EAAOZ,EAAIY,EAAO,GAAIlB,GAGxCsB,GAAAA,EAAWC,MAAQN,EAAe,CACnBK,IAAAA,EAAAA,EAAWE,SAApBnB,EAAAA,EAAAA,EAAGC,EAAAA,EAAAA,EACXJ,EAAKC,MAAMC,EAAKC,EAAIa,EAAOZ,EAAIY,EAAO,GAAIjB,MAM1CwB,EAAe,CACnBC,UAAW,cACXC,MAAO,CACLC,aAAc,cACdC,aAAc,GACdC,gBAAiB,IACjBC,WAAY,IACZC,WAAY,GAEdC,oBAAqB,CACnBC,kBAAmB,GACnBC,kBAAmB,IAErBC,OAAQ,CACNC,WAAW,EACXC,YAAY,IAIVC,EAAW,WACf,MAAA,WAAWC,KAAKC,UAAUC,YAC1B,oBAAoBF,KAAKC,UAAUC,YAE/BC,EAAW,WAAA,IAAA,EAAA,EAAG,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EACd,GAACF,UAAUG,cAAiBH,UAAUG,aAAaC,aADrC,CAAA,EAAA,KAAA,EAAA,MAEV,MAAA,IAAIC,MACR,iEAHc,KAAA,EAWGL,OALfM,EAASR,KACTS,EAAQC,SAASC,eAAe,UAChCC,MAAQrD,EACdkD,EAAMI,OAASrD,EATG,EAAA,KAAA,EAWG0C,UAAUG,aAAaC,aAAa,CACvDQ,OAAO,EACPL,MAAO,CACLM,WAAY,OACZH,MAAOJ,OAASQ,EAAYzD,EAC5BsD,OAAQL,OAASQ,EAAYxD,KAhBf,KAAA,EAqBX,OAVDyD,EAXY,EAAA,KAmBlBR,EAAMS,UAAYD,EAEX,EAAA,OAAA,SAAA,IAAIE,QAAQ,SAAAC,GACjBX,EAAMY,iBAAmB,WAAMD,OAAAA,EAAQX,OAtBvB,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,MAAdL,OAAAA,WAAW,OAAA,EAAA,MAAA,KAAA,YAAA,GA0BXkB,EAAS,WAAA,IAAA,EAAA,EAAG,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EACIlB,OADJ,EAAA,KAAA,EACIA,IADJ,KAAA,EAGTK,OAFDA,EADU,EAAA,MAEVc,OACCd,EAAAA,OAAAA,SAAAA,GAHS,KAAA,EAAA,IAAA,MAAA,OAAA,EAAA,SAAA,MAAZa,OAAAA,WAAS,OAAA,EAAA,MAAA,KAAA,YAAA,GAMTE,EAAuB,SAACf,EAAOgB,GAC7BC,IAAAA,EAAShB,SAASC,eAAe,UACjC9C,EAAM6D,EAAOC,WAAW,MACxBC,GAAqB,EAKZC,SAAAA,IAR8B,OAAA,EAAA,MAAA,KAAA,WAAA,SAAA,IAAA,OAAA,EAAA,EAQ7C,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EACMC,EAAQ,GAIJ5C,EAAAA,GAAAA,EAAaC,UACd,EAAA,KAAA,gBAAA,EAAA,GANT,EAAA,GAAA,MAAA,KAAA,EAOyBsC,OAPzB,EAAA,KAAA,EAOyBA,EAAMM,cAActB,EAAO,CAC5CuB,eAAgBJ,EAChBK,eAAgB,kBATxB,KAAA,EAAA,OAOYC,EAPZ,EAAA,KAWMJ,EAAQA,EAAMK,OAAOD,GACrBvC,GAAqBT,EAAaQ,oBAAoBC,kBACtDC,GAAqBV,EAAaQ,oBAAoBE,kBAb5D,EAAA,OAAA,QAAA,IAAA,KAAA,GAiBE/B,EAAIuE,UAAU,EAAG,EAAG7E,EAAYC,GAE5B0B,EAAaW,OAAOC,YACtBjC,EAAIwE,OACJxE,EAAIc,OAAO,EAAG,GACdd,EAAIyE,WAAW/E,EAAY,GAC3BM,EAAI0E,WAGNT,EAAMU,QAAQ,SAA0B,GAAvBxD,IAAAA,EAAAA,EAAAA,MAAOP,EAAAA,EAAAA,UAClBO,GAASW,GACPT,EAAaW,OAAOE,YACtBpC,EAAKa,UAAUC,EAAWmB,EAAmB/B,KAInD4E,sBAAsBZ,GAjCxB,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,OAR6C,MAAA,KAAA,WAK7CH,EAAOd,MAAQrD,EACfmE,EAAOb,OAASrD,EAsChBqE,KAGaa,SAAAA,IAqBf,OAAA,EAAA,MAAA,KAAA,WAAA,SAAA,IAAA,OAAA,EAAA,EArBA,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EAE2BC,OAF3B,EAAA,KAAA,EAE2BA,QAAQC,KAAK,CACpCvD,aAAcH,EAAaE,MAAMC,aACjCC,aAAcJ,EAAaE,MAAME,aACjCC,gBAAiBL,EAAaE,MAAMG,gBACpCC,WAAYN,EAAaE,MAAMI,WAC/BC,WAAYP,EAAaE,MAAMK,aAPnC,KAAA,EAckB6B,OAZZuB,EAFN,EAAA,KAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAckBvB,IAdlB,KAAA,EAcIb,EAdJ,EAAA,KAeIe,EAAqBf,EAAOoC,GAfhC,EAAA,KAAA,GAAA,MAAA,KAAA,GAAA,MAAA,EAAA,KAAA,GAAA,EAAA,GAAA,EAAA,MAAA,GAAA,EAAA,GAAA,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA,EAAA,UAqBA,MAAA,KAAA,WAAAH,IAAQI,MAAMC,QAAQC","file":"posenet_base.16cc3c15.js","sourceRoot":"..","sourcesContent":["\"use strict\";\n\nconst videoWidth = 600;\nconst videoHeight = 500;\nconst colorLeft = \"#FF0000\";\nconst colorRight = \"#1E90FF\";\n\nconst draw = {\n  point: (ctx, y, x, r, color) => {\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, 2 * Math.PI);\n    ctx.fillStyle = color;\n    ctx.fill();\n  },\n  keyPoints: (keypoints, minConfidence, ctx, scale = 1) => {\n    let leftWrist = keypoints.find(point => point.part === \"leftWrist\");\n    let rightWrist = keypoints.find(point => point.part === \"rightWrist\");\n\n    if (leftWrist.score > minConfidence) {\n      const { y, x } = leftWrist.position;\n      draw.point(ctx, y * scale, x * scale, 10, colorLeft);\n    }\n\n    if (rightWrist.score > minConfidence) {\n      const { y, x } = rightWrist.position;\n      draw.point(ctx, y * scale, x * scale, 10, colorRight);\n    }\n  }\n};\n\n// We create an object with the parameters that we want for the model.\nconst poseNetState = {\n  algorithm: \"single-pose\",\n  input: {\n    architecture: \"MobileNetV1\",\n    outputStride: 16,\n    inputResolution: 513,\n    multiplier: 0.75,\n    quantBytes: 2\n  },\n  singlePoseDetection: {\n    minPoseConfidence: 0.1,\n    minPartConfidence: 0.5\n  },\n  output: {\n    showVideo: true,\n    showPoints: true\n  }\n};\n\nconst isMobile = () =>\n  /Android/i.test(navigator.userAgent) ||\n  /iPhone|iPad|iPod/i.test(navigator.userAgent);\n\nconst setupCamera = async () => {\n  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n    throw new Error(\n      \"Browser API navigator.mediaDevices.getUserMedia not available\"\n    );\n\n  const mobile = isMobile();\n  const video = document.getElementById(\"video\");\n  video.width = videoWidth;\n  video.height = videoHeight;\n\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: false,\n    video: {\n      facingMode: \"user\",\n      width: mobile ? undefined : videoWidth,\n      height: mobile ? undefined : videoHeight\n    }\n  });\n  video.srcObject = stream;\n\n  return new Promise(resolve => {\n    video.onloadedmetadata = () => resolve(video);\n  });\n};\n\nconst loadVideo = async () => {\n  const video = await setupCamera();\n  video.play();\n  return video;\n};\n\nconst detectPoseInRealTime = (video, model) => {\n  const canvas = document.getElementById(\"output\");\n  const ctx = canvas.getContext(\"2d\");\n  const flipPoseHorizontal = true;\n\n  canvas.width = videoWidth;\n  canvas.height = videoHeight;\n\n  async function poseDetectionFrame() {\n    let poses = [];\n    let minPoseConfidence;\n    let minPartConfidence;\n\n    switch (poseNetState.algorithm) {\n      case \"single-pose\":\n        const pose = await model.estimatePoses(video, {\n          flipHorizontal: flipPoseHorizontal,\n          decodingMethod: \"single-person\"\n        });\n        poses = poses.concat(pose);\n        minPoseConfidence = +poseNetState.singlePoseDetection.minPoseConfidence;\n        minPartConfidence = +poseNetState.singlePoseDetection.minPartConfidence;\n        break;\n    }\n\n    ctx.clearRect(0, 0, videoWidth, videoHeight);\n\n    if (poseNetState.output.showVideo) {\n      ctx.save();\n      ctx.scale(-1, 1);\n      ctx.translate(-videoWidth, 0);\n      ctx.restore();\n    }\n\n    poses.forEach(({ score, keypoints }) => {\n      if (score >= minPoseConfidence) {\n        if (poseNetState.output.showPoints) {\n          draw.keyPoints(keypoints, minPartConfidence, ctx);\n        }\n      }\n    });\n    requestAnimationFrame(poseDetectionFrame);\n  }\n\n  poseDetectionFrame();\n};\n\nasync function start() {\n  // We load the model.\n  let poseNetModel = await posenet.load({\n    architecture: poseNetState.input.architecture,\n    outputStride: poseNetState.input.outputStride,\n    inputResolution: poseNetState.input.inputResolution,\n    multiplier: poseNetState.input.multiplier,\n    quantBytes: poseNetState.input.quantBytes\n  });\n\n  // we instantiate a video stream\n  let video;\n\n  try {\n    video = await loadVideo();\n    detectPoseInRealTime(video, poseNetModel);\n  } catch (e) {\n    throw e;\n  }\n}\n\nstart().catch(console.error);\n"]}